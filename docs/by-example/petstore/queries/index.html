<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Http4s Modules by Example - Petstore Queries · Http4s Modules Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Now that we have our initial schema defined, we need to write some queries that allow us to communicate with the database. To figure out what kinds of queries we will need, let us proceed with defining a simple algebra for the set of operations that should be available."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Http4s Modules by Example - Petstore Queries · Http4s Modules Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://clovellytech.github.io/http4s-modules/"/><meta property="og:description" content="Now that we have our initial schema defined, we need to write some queries that allow us to communicate with the database. To figure out what kinds of queries we will need, let us proceed with defining a simple algebra for the set of operations that should be available."/><meta property="og:image" content="https://clovellytech.github.io/http4s-modules/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://clovellytech.github.io/http4s-modules/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/http4s-modules/"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/http4s-modules/js/scrollSpy.js"></script><link rel="stylesheet" href="/http4s-modules/css/main.css"/><script src="/http4s-modules/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/http4s-modules/"><h2 class="headerTitle">Http4s Modules Docs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"></ul></nav></div></header></div></div><div class="navPusher singleRowMobileNav"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Http4s Modules by Example - Petstore Queries</h1></header><article><div><span><p>Now that we have our initial schema defined, we need to write some queries that allow us to communicate with the database. To figure out what kinds of queries we will need, let us proceed with defining a simple algebra for the set of operations that should be available.</p>
<h2><a class="anchor" aria-hidden="true" id="specifying-domain"></a><a href="#specifying-domain" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specifying Domain</h2>
<p>First, a pet in our application will have a few attributes, mirroring what we declared in our postgres table definition in the previous page:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.<span class="hljs-type">UUID</span>
<span class="hljs-keyword">import</span> java.time.<span class="hljs-type">Instant</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetA</span>(<span class="hljs-params">
  petId: <span class="hljs-type">UUID</span>,
  createTime: <span class="hljs-type">Option</span>[<span class="hljs-type">Instant</span>],
  updateTime: <span class="hljs-type">Option</span>[<span class="hljs-type">Instant</span>],
  name: <span class="hljs-type">String</span>,
  bio: <span class="hljs-type">String</span>,
  createdBy: <span class="hljs-type">Option</span>[<span class="hljs-type">UUID</span>],
  status: <span class="hljs-type">String</span>,
  photoUrls: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]
</span>)</span>
</code></pre>
<p>Pets require creation, read, and update. A simple algebra could read as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PetAlgebra1</span>[<span class="hljs-type">F</span>[_]]</span>{
  <span class="hljs-comment">// Create a pet, discard errors if creation impossible</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span></span>(pet: <span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>]

  <span class="hljs-comment">// look for a single pet by id</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectById</span></span>(petId: <span class="hljs-type">UUID</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Pet</span>]]

  <span class="hljs-comment">// Update a single pet by an id.</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(petId: <span class="hljs-type">UUID</span>, pet:<span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>]
}
</code></pre>
<p>This has a few issues though. Firstly, the pet's id is generated by postgres, so we do not want to have to drag it around in our application layer. We could make the <code>petId</code> an <code>Option[UUID]</code>, but this would also be wrong. If a <code>Pet</code>'s <code>petId</code> is <code>None</code>, does that mean that the pet does not exist in the database yet? Or does it mean that it might exist, but we just don't have the database id available?</p>
<p>Let us try another way.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  bio: <span class="hljs-type">String</span>,
  createdBy: <span class="hljs-type">Option</span>[<span class="hljs-type">UUID</span>],
  status: <span class="hljs-type">String</span>,
  photoUrls: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>],
  updateTime: <span class="hljs-type">Option</span>[<span class="hljs-type">Instant</span>] = <span class="hljs-type">None</span>
</span>)</span>
</code></pre>
<p>We have dropped all the fields that are created by the database.  Now we have the problem in our algebra of how to represent these fields.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> h4sm.db.<span class="hljs-type">CRUAlgebra</span>

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PetAlgebra</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">CRUAlgebra</span>[<span class="hljs-type">F</span>, <span class="hljs-type">UUID</span>, <span class="hljs-type">Pet</span>, <span class="hljs-type">Instant</span>]</span>
</code></pre>
<p>And that's all we have to write. PetAlgebra will have a type member <code>Annotated</code>, which will be <code>(Pet, UUID, Instant)</code>, referring to the base datatype <code>Pet</code>, it's id type, and the remaining fields that the database is in control of.</p>
<p>Let's see how this translates to writing a repository for this algebra:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">OptionT</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetRepositoryUnimplemented</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">PetAlgebra</span>[<span class="hljs-type">F</span>]</span>{
  <span class="hljs-comment">// Members declared in h4sm.db.CAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span></span>(a: <span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>] = ???

  <span class="hljs-comment">// OptionT is used here as a way to handle unresolved insert collisions. We don't have any unique fields on</span>
  <span class="hljs-comment">// our pets.</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertGetId</span></span>(a: <span class="hljs-type">Pet</span>): <span class="hljs-type">OptionT</span>[<span class="hljs-type">F</span>,<span class="hljs-type">UUID</span>] = ???

  <span class="hljs-comment">// Members declared in h4sm.db.RAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byId</span></span>(id: <span class="hljs-type">UUID</span>): <span class="hljs-type">OptionT</span>[<span class="hljs-type">F</span>,<span class="hljs-type">Annotated</span>] = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Annotated</span>]] = ???

  <span class="hljs-comment">// Members declared in h4sm.db.UAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(id: <span class="hljs-type">UUID</span>, u: <span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>] = ???
}
</code></pre>
<p>The members shown above show the base methods expected by <code>PetAlgebra</code>.</p>
<p>Each of these methods will require a query available. So let's begin by writing some queries.</p>
<pre><code class="hljs css language-scala">import doobie._
import doobie.implicits._
import doobie.postgres.implicits._
import h4sm.auth.db.sql._
import h4sm.auth.comm.authIdTypes._

trait PetSql{
  def insert(a: Pet): Update0 = sql"""
    insert into ct_petstore.pet (name, bio, status, created_by, photo_urls)
    values (${a.name}, ${a.bio}, ${a.status}, ${a.createdBy}, ${a.photoUrls})
  """.update

  def insertGetId(a: Pet): ConnectionIO[UUID] = insert(a).withUniqueGeneratedKeys("pet_id")

  def select: Query0[(Pet, UUID, Instant)] = sql"""
    select name, bio, created_by, status, photo_urls, update_time, pet_id, create_date
    from ct_petstore.pet
  """.query

  def selectById(uuid: UUID): Query0[(Pet, UUID, Instant)] = (select.toFragment ++ fr"""
    where pet_id = $uuid
  """).query

  def update(id: UUID, pet: Pet): Update0 = sql"""
    update ct_petstore.pet
    set name = ${pet.name}, bio = ${pet.bio}, update_time = now(), status = ${pet.status}, photo_urls = ${pet.photoUrls}
    where pet_id = $id
  """.update

  def selectByName(name: String): Query0[(Pet, UUID, Instant)] = (select.toFragment ++ fr"""
    where name = $name
  """).query
}

object PetSql extends PetSql
</code></pre>
<p>To make our testing easier, I'll write an arbitrary generator to build <code>Pet</code>s:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.implicits._
<span class="hljs-keyword">import</span> org.scalacheck.{<span class="hljs-type">Arbitrary</span>, <span class="hljs-type">Gen</span>}
<span class="hljs-keyword">import</span> org.scalacheck.cats.implicits._
<span class="hljs-keyword">import</span> h4sm.testutil.arbitraries._

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">arbitraries</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> arbPet: <span class="hljs-type">Arbitrary</span>[<span class="hljs-type">Pet</span>] = <span class="hljs-type">Arbitrary</span>(
    (
      nonEmptyString,
      nonEmptyString,
      <span class="hljs-type">Gen</span>.option(<span class="hljs-type">Gen</span>.uuid),
      nonEmptyString,
      <span class="hljs-type">Gen</span>.listOf(nonEmptyString),
      <span class="hljs-type">Gen</span>.option(arbInstant.arbitrary),
    ).mapN(<span class="hljs-type">Pet</span>.apply _)
  )
}
</code></pre>
<p>Now all our queries are available as <code>PetSql</code>. Let's write some typechecking tests:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> h4sm.db.config.<span class="hljs-type">DatabaseConfig</span>
<span class="hljs-keyword">import</span> h4sm.testutil.arbitraries._
<span class="hljs-keyword">import</span> h4sm.testutil.<span class="hljs-type">DbFixtureSuite</span>
<span class="hljs-keyword">import</span> h4sm.testutil.transactor.getTransactor
<span class="hljs-keyword">import</span> doobie.scalatest.<span class="hljs-type">IOChecker</span>
<span class="hljs-keyword">import</span> doobie.<span class="hljs-type">Transactor</span>
<span class="hljs-keyword">import</span> arbitraries._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetSqlTestSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DbFixtureSuite</span> <span class="hljs-keyword">with</span> <span class="hljs-title">IOChecker</span> </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testConfig</span></span>: <span class="hljs-type">DatabaseConfig</span> = config.copy(databaseName = <span class="hljs-string">"petstoretest"</span>) <span class="hljs-comment">// only needed for documentation</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">colors</span> </span>= doobie.util.<span class="hljs-type">Colors</span>.<span class="hljs-type">None</span> <span class="hljs-comment">// only needed for documentation</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">schemaNames</span> </span>= <span class="hljs-type">List</span>(<span class="hljs-string">"ct_auth"</span>, <span class="hljs-string">"ct_files"</span>, <span class="hljs-string">"ct_permissions"</span>, <span class="hljs-string">"ct_petstore"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transactor</span></span>: <span class="hljs-type">Transactor</span>[<span class="hljs-type">IO</span>] = getTransactor[<span class="hljs-type">IO</span>](cfg)

  test(<span class="hljs-string">"insert should typecheck"</span>)(_ =&gt; check(applyArb(<span class="hljs-type">PetSql</span>.insert _)))
  test(<span class="hljs-string">"select by id should typecheck"</span>)(_ =&gt; check(applyArb(<span class="hljs-type">PetSql</span>.selectById _)))
  test(<span class="hljs-string">"select user files should typecheck"</span>)(_ =&gt; check(applyArb(<span class="hljs-type">PetSql</span>.selectByName _)))
  test(<span class="hljs-string">"update upload time should typecheck"</span>)(_ =&gt; check(applyArb((<span class="hljs-type">PetSql</span>.update _).tupled)))
}
</code></pre>
<p>Note the use of <code>DbFixtureSuite</code>, which will automatically create and then destroy a test postgres database for us.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> t = <span class="hljs-keyword">new</span> <span class="hljs-type">PetSqlTestSpec</span>
<span class="hljs-comment">// t: PetSqlTestSpec = repl.Session$App$PetSqlTestSpec@31f4ca14</span>
t.execute(color = <span class="hljs-literal">false</span>)
<span class="hljs-comment">// Session$App$PetSqlTestSpec:</span>
<span class="hljs-comment">// - insert should typecheck</span>
<span class="hljs-comment">// - select by id should typecheck *** FAILED ***</span>
<span class="hljs-comment">//   Query0[(App.Pet, UUID, Instant)] defined at 02-queries.md:117</span>
<span class="hljs-comment">//     select name, bio, created_by, status, photo_urls, update_time,</span>
<span class="hljs-comment">//     pet_id, create_date</span>
<span class="hljs-comment">//     from ct_petstore.pet</span>
<span class="hljs-comment">//     where pet_id = ?</span>
<span class="hljs-comment">//     ✓ SQL Compiles and TypeChecks</span>
<span class="hljs-comment">//     ✓ P01 UUID  →  OTHER (uuid)</span>
<span class="hljs-comment">//     ✓ C01 name        VARCHAR   (text)        NOT NULL  →  String</span>
<span class="hljs-comment">//     ✕ C02 bio         VARCHAR   (text)        NULL      →  String</span>
<span class="hljs-comment">//       Reading a NULL value into String will result in a runtime failure.</span>
<span class="hljs-comment">//       Fix this by making the schema type NOT NULL or by changing the</span>
<span class="hljs-comment">//       Scala type to Option[String]</span>
<span class="hljs-comment">//     ✓ C03 created_by  OTHER     (uuid)        NOT NULL  →  Option[UUID]</span>
<span class="hljs-comment">//     ✓ C04 status      VARCHAR   (text)        NOT NULL  →  String</span>
<span class="hljs-comment">//     ✓ C05 photo_urls  ARRAY     (_text)       NOT NULL  →  Array[String]</span>
<span class="hljs-comment">//     ✓ C06 update_time TIMESTAMP (timestamptz) NOT NULL  →  Option[Timestamp]</span>
<span class="hljs-comment">//     ✓ C07 pet_id      OTHER     (uuid)        NOT NULL  →  UUID</span>
<span class="hljs-comment">//     ✓ C08 create_date TIMESTAMP (timestamptz) NOT NULL  →  Timestamp (Checker.scala:56)</span>
<span class="hljs-comment">// - select user files should typecheck *** FAILED ***</span>
<span class="hljs-comment">//   Query0[(App.Pet, UUID, Instant)] defined at 02-queries.md:127</span>
<span class="hljs-comment">//     select name, bio, created_by, status, photo_urls, update_time,</span>
<span class="hljs-comment">//     pet_id, create_date</span>
<span class="hljs-comment">//     from ct_petstore.pet</span>
<span class="hljs-comment">//     where name = ?</span>
<span class="hljs-comment">//     ✓ SQL Compiles and TypeChecks</span>
<span class="hljs-comment">//     ✓ P01 String  →  VARCHAR (text)</span>
<span class="hljs-comment">//     ✓ C01 name        VARCHAR   (text)        NOT NULL  →  String</span>
<span class="hljs-comment">//     ✕ C02 bio         VARCHAR   (text)        NULL      →  String</span>
<span class="hljs-comment">//       Reading a NULL value into String will result in a runtime failure.</span>
<span class="hljs-comment">//       Fix this by making the schema type NOT NULL or by changing the</span>
<span class="hljs-comment">//       Scala type to Option[String]</span>
<span class="hljs-comment">//     ✓ C03 created_by  OTHER     (uuid)        NOT NULL  →  Option[UUID]</span>
<span class="hljs-comment">//     ✓ C04 status      VARCHAR   (text)        NOT NULL  →  String</span>
<span class="hljs-comment">//     ✓ C05 photo_urls  ARRAY     (_text)       NOT NULL  →  Array[String]</span>
<span class="hljs-comment">//     ✓ C06 update_time TIMESTAMP (timestamptz) NOT NULL  →  Option[Timestamp]</span>
<span class="hljs-comment">//     ✓ C07 pet_id      OTHER     (uuid)        NOT NULL  →  UUID</span>
<span class="hljs-comment">//     ✓ C08 create_date TIMESTAMP (timestamptz) NOT NULL  →  Timestamp (Checker.scala:56)</span>
<span class="hljs-comment">// - update upload time should typecheck</span>
</code></pre>
<p>Doobie's typechecking has alerted us that there is a mismatch between our queries and our domain representation. We need to handle a possibly null bio, and a possibly empty or null photo_urls.</p>
<p>We can handle a null bio by simply making that field optional in our domain object:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  bio: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>],
  createdBy: <span class="hljs-type">Option</span>[<span class="hljs-type">UUID</span>],
  status: <span class="hljs-type">String</span>,
  photoUrls: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>],
  updateTime: <span class="hljs-type">Option</span>[<span class="hljs-type">Instant</span>] = <span class="hljs-type">None</span>
</span>)</span>
</code></pre>
<p>And we can update our schema to set <code>not null</code> on photoUrls. This update has been made in the petstore module of this project. You should refer to that module code as you read this documentation.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">Bracket</span>
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-comment">// I require a Bracket[?[_], Throwable] because doobie's transact requires it.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetRepository</span>[<span class="hljs-type">F</span>[_]</span>: <span class="hljs-type">Bracket</span>[?[_], <span class="hljs-type">Throwable</span>]](xa: <span class="hljs-type">Transactor</span>[<span class="hljs-type">F</span>]) <span class="hljs-keyword">extends</span> <span class="hljs-type">PetAlgebra</span>[<span class="hljs-type">F</span>]{
  <span class="hljs-comment">// Members declared in h4sm.db.CAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span></span>(a: <span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">PetSql</span>.insert(a).run.transact(xa).void

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertGetId</span></span>(a: <span class="hljs-type">Pet</span>): <span class="hljs-type">OptionT</span>[<span class="hljs-type">F</span>,<span class="hljs-type">UUID</span>] = <span class="hljs-type">OptionT</span>.liftF(<span class="hljs-type">PetSql</span>.insertGetId(a).transact(xa))

  <span class="hljs-comment">// Members declared in h4sm.db.RAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byId</span></span>(id: <span class="hljs-type">UUID</span>): <span class="hljs-type">OptionT</span>[<span class="hljs-type">F</span>,<span class="hljs-type">Annotated</span>] = <span class="hljs-type">OptionT</span>(<span class="hljs-type">PetSql</span>.selectById(id).option.transact(xa))
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Annotated</span>]] = <span class="hljs-type">PetSql</span>.select.to[<span class="hljs-type">List</span>].transact(xa)

  <span class="hljs-comment">// Members declared in h4sm.db.UAlgebra</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(id: <span class="hljs-type">UUID</span>, u: <span class="hljs-type">Pet</span>): <span class="hljs-type">F</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">PetSql</span>.update(id, u).run.transact(xa).void
}
</code></pre>
<p>In the petstore module, these implementations are also complete for managing orders.</p>
<p>At this point, we're ready to <a href="/http4s-modules/docs/by-example/petstore/endpoints">implement our endpoints</a>.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#specifying-domain">Specifying Domain</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/http4s-modules/" class="nav-home"></a><div><h5>Docs</h5><a href="/http4s-modules/docs/">Getting Started</a></div><div><h5>Community</h5><a href="https://gitter.io/clovellytech/http4s-modules">Project Gitter Chat</a><a href="https://github.com/clovellytech/http4s-modules">GitHub</a><a class="github-button" href="https://github.com/clovellytech/http4s-modules" data-icon="octicon-star" data-count-href="/clovellytech/http4s-modules/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2020 ClovellyTech</section></footer></div></body></html>